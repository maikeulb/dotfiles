{'type': 'v', 'text': ''}
{'type': 'V', 'text': '" Textobj'}
{'type': 'v', 'text': '``'}
{'type': 'V', 'text': 'import java.util.*;class Solution {  // Interviewer drew out the illustration exactly as shown below  // <----- 0-----0--0----  // ----1-----1--------1->  // On a 2 ways lane, there are cars driving west-bound (0) and cars driving east-bound (1),  // write a function that returns the amount of times that the cars will pass by each other.  // The above illustration was turned into an array [1,0,1,0,0,1] as input and should return 5  // (first "1" will drive by 3 "0", second will drive by 2, and third will drive by 0).  // This basically translates to summing the number of zeros after a one for every one in the input  // array.  // You could do it in O(N) time and O(N) space in two passes by making a prefix sum.  // Maintain a count for the number of 1s seen so far  // Everytime you encounter a 0, add the number of 1s seen so far to the answer.  // print(num_cross([1,1,0,0]))         # 4  // print(num_cross([1,0]))             # 1  // print(num_cross([0,1]))             # 0  // print(num_cross([1,0,1,0,0,1]))     # 5  static int numCross(int[] nums) {    int onesSeenSoFar = 0;    int ans = 0;    for (int num : nums) {      if (num == 1) {        onesSeenSoFar++;      } else {        ans += onesSeenSoFar;      }    }    return ans;  }  public static void main(String[] args) {    int[] nums = new int[] {1, 1, 0, 0};    System.out.println(numCross(nums)); // 4    nums = new int[] {1, 0, 1, 0, 0, 1};     System.out.println(numCross(nums)); // 5    nums = new int[] {0, 1};    System.out.println(numCross(nums)); // 0  }}'}
{'type': 'V', 'text': 'nnoremap <C-j> iclass <ESC>"%pxxxxxa {<ESC>opublic static void main(String args[]){<Esc>o<Esc>o}<Esc>o}<Esc>kki<Tab><Tab>'}
{'type': 'v', 'text': 'Navigation'}
{'type': 'V', 'text': '" Navigation'}
{'type': 'V', 'text': '" Plug ''PeterRincker/vim-argumentative'''}
{'type': 'V', 'text': 'Plug ''google/vim-codefmt'''}
{'type': 'V', 'text': '" Plug ''Chiel92/vim-autoformat'''}
{'type': 'V', 'text': '" Plug ''google/vim-maktaba'''}
{'type': 'V', 'text': 'Plug ''unblevable/quick-scope'''}
{'type': 'V', 'text': 'Plug ''tpope/vim-commentary''Plug ''tpope/vim-surround'''}
{'type': 'V', 'text': 'import java.util.*;class Solution {  static char OPEN = ''('';  static char CLOSE = '')'';  static int longestValidParentheses(String s, int n) {    // st<pos of OPEN>: push OPEN indices and pop when closed    Deque<Integer> st = new ArrayDeque<>();    // mark places where indices are valid    int[] valid = new int[n];    for (int i = 0; i < n; i++) {      if (s.charAt(i) == OPEN) { // push        st.push(i);      } else if (!st.isEmpty() && s.charAt(i) == CLOSE) { // check if not empty        // OPEN and CLOSED are valid        valid[st.pop()] = valid[i] = 1;      }      // no need to break because anything between 1 and 1 is valid    }    return maxConsecutiveOnes(valid);  }  static int maxConsecutiveOnes(int[] a) {    int maxSoFar = 0;    int maxEndingHere = 0;    for (int v : a) {      // if 1, increment, else restart at 0      maxEndingHere = v == 1 ? maxEndingHere + 1 : 0;      maxSoFar = Math.max(maxSoFar, maxEndingHere);    }    return maxSoFar;  }  public static void main(String[] args) {    // String s = "(()))";    String s = "()(()";    int n = s.length();    System.out.println(longestValidParentheses(s, n));  }}'}
{'type': 'V', 'text': 'import java.util.*;class Solution {  static int n;  static int M;  static int N;  static char[][] board;  static boolean[][] marked;  static int[][] dirs = {{-1, 1}, {-1, 0}, {-1, -1}, {0, -1}, {1, -1}, {1, 1}, {0, 1}};  static String[] dictionary = {"GEEKS", "FOR", "QUIZ", "GEEK"};  static List<String> res;  static void findWords() {    res = new ArrayList<>();    // start at every cell    for (int r = 0; r < M; r++) {      for (int c = 0; c < N; c++) {        marked = new boolean[M][N];        marked[r][c] = true;        dfs(r, c, "" + board[r][c]);      }    }  }  // vertex combinations  // forward recursion  static void dfs(int r, int c, String path) {    // base case: destination reached (word found)    if (isWord(path)) {      res.add(path);    }        // transition: try every next adjacent vertex    for (int[] d : dirs) {      int nr = r + d[0];      int nc = c + d[1];      if (isValid(nr, nc) && !marked[nr][nc]) {        marked[nr][nc] = true;        dfs(nr, nc, path + board[nr][nc]);        marked[nr][nc] = false;      }    }  }  static boolean isValid(int r, int c) {    return r >= 0 && r < N && c >= 0 && c < N;  }  static boolean isWord(String path) {    for (int i = 0; i < n; i++) {      if (path.equals(dictionary[i])) {        return true;      }    }    return false;  }  public static void main(String[] args) {    board = new char[][] {{''G'', ''I'', ''Z''}, {''U'', ''E'', ''K''}, {''Q'', ''S'', ''E''}};    n = dictionary.length;    M = board.length;    N = board[0].length;    findWords();    System.out.println(res);  }}'}
{'type': 'V', 'text': 'import java.util.*;class Solution {  static boolean checkValidString(String s) {    // focus on counting open paren    int open = 0;    for (char ch : s.toCharArray()) {      if (ch == ''('') { // simulate push        open++;      } else if (open > 0 && ch == '')'') { // simulate pop        open--;      } else {        return false;      }    }    return open == 0;   }  public static void main(String[] args) {    String s = "(*)";    System.out.println(checkValidString(s));  }}'}
{'type': 'V', 'text': 'import java.util.*;// reservoir sampling:// Given a list of offsets (i.e. prefix sums) and a target offset,// our task is to fit the target offset into the list so that the ascending order is maintainedclass RandomizedPick {  int n;  int[] prefixSum;  Random rand;  // 1, 5, 2  // 0 1 1 1 1 1 2 2  // 1 6 8  RandomizedPick(int[] w) {    n = w.length;    rand = new Random();    prefixSum = new int[n];    prefixSum[0] = w[0];    for (int i = 1; i < n; i++) {      prefixSum[i] = prefixSum[i - 1] + w[i];    }  }  int pickIndex() {    // rand.nextInt is exclusive    // [1, totalSum] // rand [0, totalSum) ==> + 1 => [1, totalSum]    int p = rand.nextInt(prefixSum[n - 1]) + 1;    int it = lowerbound(p);    System.out.println(it);    return it;  }  // f f f t t t => find first t  // first greater/equal  int lowerbound(int pick) {    int l = 0, h = n - 1;    while (l < h) {      int m = l + (h - l) / 2;      if (prefixSum[m] >= pick) {        h = m;      } else {        l = m + 1;      }    }    return l;  }  int linear(int pick) {    int i = 0;    while (i < n) {      if (prefixSum[i] >= pick) break;      i++;    }    return i;  }  public static void main(String[] args) {    int[] w = {1, 3};    RandomizedPick rp = new RandomizedPick(w);    rp.pickIndex();  }}'}
{'type': 'V', 'text': '      // this is bc must ensure that ai goes before ai-1'}
{'type': 'V', 'text': 'import java.util.*;class Solution {  static String encode(String s, int n) {    StringBuilder encoded = new StringBuilder();    // iterate left pointer    int l = 0;    while (l < n) {      // find [l, r] for contiguous duplicate segment      // iterate right pointer while equal      int r = l;      while (r < n && s.charAt(l) == s.charAt(r)) {        r++;      }      // append to output      encoded.append(r - l);      encoded.append(s.charAt(l));      // catchup (r is over by one due to while loop)      l = r;    }    return encoded.toString();  }  static String decode(String s, int n) {    StringBuilder expanded = new StringBuilder();    int i = 0;    while (i < n) {      // find num      int num = 0;      while (i < n && Character.isDigit(s.charAt(i))) {        num *= 10;        num += Character.digit(s.charAt(i++), 10);      }      // append to output num times      int repeat = num;      while (repeat > 0) {        expanded.append(s.charAt(i));        repeat--;      }      i++;    }    return expanded.toString();  }  public static void main(String[] args) {    String str = "wwwwaaadexxxxxxywww";    String encoded = encode(str, str.length());    // String decoded = decode(encoded, encoded.length());    System.out.println(encoded);    // System.out.println(decoded);  }}'}
{'type': 'V', 'text': 'import java.util.*;class Solution {  static String res;  // You are given two string arrays username and website and an integer array timestamp. All the  // given arrays are of the same length and the tuple [username[i], website[i], timestamp[i]]  // indicates that the user username[i] visited the website[i] at time timestamp[i].  static List<String> mostVisitedPattern(String[] user, int[] tstamp, String[] website, int n) {    // 1. group users to seperate visit patterns for each user    // group<users, webVisits>: group users to list of webVisits    Map<String, List<WebTime>> group = new HashMap<>();    for (int i = 0; i < n; i++) {      group.putIfAbsent(user[i], new ArrayList<>());      group.get(user[i]).add(new WebTime(tstamp[i], website[i]));    }    // freq: every 3-subsequence for DIFFERENT users    Map<String, Integer> freq = new HashMap<>();    // 2. analyze visit pattern for each user    res = "";    for (String users : group.keySet()) {      List<WebTime> webVisits = group.get(users);      // sort webVisits to avoid seeing 3-subsequence multiple times      Collections.sort(webVisits, (a, b) -> (a.time - b.time));      findUniqueThreeWebs(freq, webVisits);    }    List<String> res = new ArrayList<>();    for (String key : res.split(" ")) {      res.add(key);    }    return res;  }  static void findUniqueThreeWebs(Map<String, Integer> freq, List<WebTime> visits) {    // seen: each visit pattern FOR single user    Set<String> seen = new HashSet<>();    // iterate 3-subsequence per user to record occurrence times    for (int i = 0; i < visits.size(); i++) {      for (int j = i + 1; j < visits.size(); j++) {        for (int k = j + 1; k < visits.size(); k++) {          // track every 3 sequence combination          String key = hash(visits.get(i).web, visits.get(j).web, visits.get(k).web);          if (!seen.contains(key)) {            // increment sequence            freq.put(key, freq.getOrDefault(key, 0) + 1);            seen.add(key);          }          // update mostFrequent 3-subsequence          if (res.equals("") || isMoreFrequent(res, key, freq)) {            res = key;          }        }      }    }  }  static boolean isMoreFrequent(String res, String key, Map<String, Integer> freq) {    return freq.get(res) < freq.get(key)        || (freq.get(res) == freq.get(key) && res.compareTo(key) > 0);  }  static class WebTime {    int time;    String web;    public WebTime(int time, String web) {      this.time = time;      this.web = web;    }  }  static String hash(String web1, String web2, String web3) {    return web1 + "|" + web2 + "|" + web3;  }  public static void main(String[] args) {    String[] username = {      "joe", "joe", "joe", "james", "james", "james", "james", "mary", "mary", "mary"    };    int[] timestamp = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};    String[] website = {      "home", "about", "career", "home", "cart", "mps", "home", "home", "about", "career"    };    int n = username.length;    System.out.println(mostVisitedPattern(username, timestamp, website, n));  }}'}
{'type': 'v', 'text': 'kpr'}
{'type': 'V', 'text': '  // 9b  5b  // 9   0                   9  // 4   5 transfer 9B -> 5b 9  // 4   0 dump 5b           4  // 0   4 transfer 9b - 5b  4  //  // 9   4 fill 9b           13  // 8   5 transfer 9B -> 5b 13  // 8   0 dump 5b           8  // 3   5 transfer 9B -> 5b 8  //  // 9   5 fill 9b           14  // 9   5 transfer 9B -> 5b  // 9   0 dump 5b  // 4   0 transfer 9B -> 5b'}
{'type': 'v', 'text': '8'}
{'type': 'v', 'text': 'transfer 9B -> 5b '}
{'type': 'V', 'text': '  // 9b  5b  // 9   0   // 4   5 transfer 9B -> 5b   // 4   0 dump 5b  // 0   4 transfer 9b - 5b  // 9   4 fill 9b  //  // 8   5 transfer 9B -> 5b  // 8   0 dump 5b  // 3   5 transfer 9B -> 5b  // 9   5 fill 9b  //  // 9   5 transfer 9B -> 5b  // 9   0 dump 5b  // 4   0 transfer 9B -> 5b'}
{'type': 'V', 'text': '  // 9   0 '}
{'type': 'V', 'text': '  // 9b  5b  // 9   0   // 4   5 transfer 9B -> 5b   // 4   0 dump 5b  // 0   4 transfer 9b - 5b  // 9   4 fill 9b  //  // 8   5 transfer 9B -> 5b  // 8   0 dump 5b  // 3   5 transfer 9B -> 5b  // 9   5 fill 9b  //  // 9   5 transfer 9B -> 5b  // 9   0 dump 5b  // 4   0 transfer 9B -> 5b  static List<Integer> bucketIncrements() {    Set<int[]> set = new HashSet<>();    Set<Integer> res = new HashSet<>();    int maxIter = 50;    int count = 0;    int[] state = {0, 0};    while (true) {      if (maxIter == count) break;      res.add(state[0]);      res.add(state[1]);      state = nextState(state);      count++;    }'}
{'type': 'V', 'text': '  // 9b  5b  // 9   0   // 4   5 transfer 9B -> 5b   // 4   0 dump 5b  // 0   4 transfer 9b - 5b  // 9   4 fill 9b  //  // 8   5 transfer 9B -> 5b  // 8   0 dump 5b  // 3   5 transfer 9B -> 5b  // 9   5 fill 9b  //  // 9   5 transfer 9B -> 5b  // 9   0 dump 5b  // 4   0 transfer 9B -> 5b  static List<Integer> bucketIncrements() {'}
{'type': 'v', 'text': 'fill 9b'}
{'type': 'V', 'text': '  // 9b  5b  // 9   0 fill 9b  // 4   5 transfer 9B -> 5b   // 4   0 dump 5b  // 0   4 transfer 9b - 5b  // 9   4 fill 9b  // 8   5 transfer 9B -> 5b  // 8   0 dump 5b  // 3   5 transfer 9B -> 5b'}
{'type': 'V', 'text': '  // 9   4 fill 9b  // 8   4 transfer 9B -> 5b  // 8   0 dump 5b  // 7   5 transfer 9B -> 5b'}
{'type': 'v', 'text': '  //'}
{'type': 'v', 'text': 'transfer 9B -> 5b'}
{'type': 'v', 'text': 'capacity5'}
{'type': 'v', 'text': 'bucketCap5'}
{'type': 'v', 'text': ' 9b -> 5a'}
{'type': 'v', 'text': '    state[0] ='}
{'type': 'V', 'text': '      res.add(state[0]);'}
{'type': 'v', 'text': 'set'}
{'type': 'v', 'text': ' ()'}
{'type': 'v', 'text': 'bucket9Capacity'}
{'type': 'v', 'text': 'n'}
{'type': 'v', 'text': 'graph'}
{'type': 'V', 'text': '  static List<Itinerary> sortItineraries(List<Itinerary> itineraries) {    buildGraph(itineraries);    buildMap(itineraries);    List<Itinerary> res = new ArrayList<>();    String curr = start;    while (map.get(curr) != null) {      res.add(map.get(curr));      curr = graph.get(curr);    }    return res;  }'}
{'type': 'V', 'text': '  static class Itinerary {    int id;    String from;    String to;    Itinerary(int id, String from, String to) {      this.id = id;      this.from = from;      this.to = to;    }        public String toString() {      return id + " " + from + " " + to;    }  }'}
{'type': 'v', 'text': 'curr'}
{'type': 'v', 'text': 'city'}
{'type': 'v', 'text': 'Itinarry'}
{'type': 'V', 'text': '  static void buildGraph(List<Itinerary> itineraries) {'}
{'type': 'v', 'text': 'indegree'}
{'type': 'v', 'text': 'nj'}
