{'type': 'v', 'text': ''}
{'type': 'V', 'text': '" Smart paste modefunction! WrapForTmux(s)  if !exists(''$TMUX'')    return a:s  endif  let l:tmux_start = "\<Esc>Ptmux;"  let l:tmux_end = "\<Esc>\\"  return l:tmux_start . substitute(a:s, "\<Esc>", "\<Esc>\<Esc>", ''g'') . l:tmux_endendfunctionlet &t_SI .= WrapForTmux("\<Esc>[?2004h")let &t_EI .= WrapForTmux("\<Esc>[?2004l")'}
{'type': 'V', 'text': '" Better Jumplistfunction! JumpInFile(back, forw)  let [n, i] = [bufnr(''%''), 1]  let p = [n] + getpos(''.'')[1:]  sil! exe ''norm!1'' . a:forw  while 1    let p1 = [bufnr(''%'')] + getpos(''.'')[1:]    if n == p1[0] | break | endif    if p == p1      sil! exe ''norm!'' . (i-1) . a:back      break    endif    let [p, i] = [p1, i+1]    sil! exe ''norm!1'' . a:forw  endwhileendfunction'}
{'type': 'V', 'text': 'function! TrimWhitespace()  let l:save = winsaveview()  keeppatterns %s/\s\+$//e  call winrestview(l:save)endfuncommand! TrimWhitespace call TrimWhitespace()function! TrimComments()  " :g/^\/\//norm D  " :g/^\/\//norm D  " :g/^\s*#\|\/\//d  :g/^\s*\/\//d  " :g/^\s*\/dendfunctioncommand! TrimComments call TrimComments()'}
{'type': 'V', 'text': 'set foldtext=NeatFoldText()'}
{'type': 'V', 'text': '" Better fold textfunction! NeatFoldText()  let l:fs = v:foldstart  while getline(l:fs) =~# ''^\s*$'' | let l:fs = nextnonblank(l:fs + 1)  endwhile  if l:fs > v:foldend    let l:line = getline(v:foldstart)  else    let l:line = substitute(getline(l:fs), ''\t'', repeat('' '', &tabstop), ''g'')  endif  let l:w = winwidth(0) - &foldcolumn - (&number ? 8 : 0)  let l:foldSize = 1 + v:foldend - v:foldstart  let l:foldSizeStr = '' '' . l:foldSize . '' lines ''  let l:foldLevelStr = repeat(''+--'', v:foldlevel)  let l:lineCount = line(''$'')  let l:foldPercentage = printf(''[%.1f'', (l:foldSize*1.0)/l:lineCount*100) . ''%] ''  let l:expansionString = repeat(''.'', l:w - strwidth(l:foldSizeStr.line.l:foldLevelStr.l:foldPercentage))  return l:line . l:expansionString . l:foldSizeStr . l:foldPercentage . l:foldLevelStrendf'}
{'type': 'V', 'text': '" Remove all commentsfunction! RemoveAllComments()  let l:initial = winnr()  execute 1 . ''wincmd w''  wincmd l  if winnr() != 1    wincmd J  else    wincmd H  endif  execute l:initial . ''wincmd w''endfunction'}
{'type': 'V', 'text': '" Change window layoutfunction! Rotate()  let l:initial = winnr()  execute 1 . ''wincmd w''  wincmd l  if winnr() != 1    wincmd J  else    wincmd H  endif  execute l:initial . ''wincmd w''endfunction'}
{'type': 'v', 'text': 'true'}
{'type': 'V', 'text': 'lua require("plugins")'}
{'type': 'V', 'text': 'lua require("settings")'}
{'type': 'v', 'text': 'plugins'}
{'type': 'v', 'text': 'This is used for'}
{'type': 'V', 'text': '-- Set fold levelset nofoldenableset foldlevel=20set foldlevelstart=20'}
{'type': 'v', 'text': 'Python prog'}
{'type': 'V', 'text': 'set nofoldenableset foldlevel=20set foldlevelstart=20'}
{'type': 'v', 'text': 'Persistent Undo'}
{'type': 'V', 'text': 'local fn       = vim.fn'}
{'type': 'v', 'text': 'vimo'}
{'type': 'V', 'text': 'local fn = vim.fn'}
{'type': 'V', 'text': '-- Persistent Undo'}
{'type': 'V', 'text': 'local undo_dir = vim.env.HOME .. "/.config/nvim/undodir"local fn       = vim.fnif not fn.isdirectory(undo_dir) then  fn.mkdir(undo_dir, "", 0700)endvim.o.undodir  = undo_dirvim.o.undofile = truevim.o.undolevels=10000vim.o.undoreload=10000'}
{'type': 'V', 'text': '  set.grepformat = set.grepformat ^ { "%f:%l:%c:%m" }'}
{'type': 'v', 'text': 'vimopt'}
{'type': 'V', 'text': '--   set grepprg=ag\ --nogroup\ --nocolor'}
{'type': 'v', 'text': 'rg'}
{'type': 'V', 'text': 'if vim.fn.executable(''rg'') > 0 then'}
{'type': 'V', 'text': 'end'}
{'type': 'V', 'text': 'if executable(''ag'')  set grepprg=ag\ --nogroup\ --nocolor  set grepformat=%f:%l:%c:%mendifif executable(''rg'')  set grepprg=rg\ --smart-case  set grepformat=%f:%l:%c:%mendif'}
{'type': 'v', 'text': 'd'}
{'type': 'V', 'text': '  set undolevels=10000  set undoreload=10000'}
{'type': 'V', 'text': 'set undodir=$HOME/.config/nvim/undodir'}
{'type': 'V', 'text': '  set undodir=$HOME/.config/nvim/undodir'}
{'type': 'v', 'text': 'set'}
{'type': 'V', 'text': 'local set = vim.opt'}
{'type': 'V', 'text': 'let g:python_host_prog = ''/usr/local/bin/python''let g:python3_host_prog = ''/usr/local/bin/python3'''}
{'type': 'V', 'text': 'if has(''clipit'')  set clipboard=unnamedendif'}
{'type': 'V', 'text': 'set.fillchars = vim.opt.fillchars + ''vert:\'''}
{'type': 'V', 'text': '-- Allow specified keys that move the cursor left/right to move to the-- previous/next line when the cursor is on the first/last character in-- the lineset.whichwrap=''b,s,h,l,<,>,[,]'''}
{'type': 'v', 'text': '--'}
{'type': 'V', 'text': '-- Maximum number of items to show in the popup menuset.pumheight = 15'}
{'type': 'V', 'text': ''}
{'type': 'V', 'text': '-- set.fillchars = vim.opt.fillchars + ''vert:\'''}
{'type': 'V', 'text': '-- ''colorcolumn'' is a comma separated list of screen columns that areset.colorcolumn = 80'}
{'type': 'V', 'text': '-- Every wrapped line will continue visually indented (same amount of space as the beginning of that line),set.breakindent = true'}
{'type': 'V', 'text': 'set.number = true'}
{'type': 'V', 'text': '-- Show the line number relative to the line with the cursor in front of each line.set.relativenumber = true'}
{'type': 'V', 'text': '-- Number of lines that is checked for set commands. set.modeline = false'}
{'type': 'V', 'text': '-- If in Insert, Replace or Visual mode put a message on the last line.set.showmode = false'}
{'type': 'V', 'text': '-- When on, the ":substitute" flag ''g'' is default on.set.gdefault = true'}
{'type': 'V', 'text': '-- When on, the ":substitute" flag ''g'' is default on.'}
